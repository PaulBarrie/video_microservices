input {
    # INPUT FOR VIDEOS
    jdbc {  
        # Here is the jdbc connection mysql statement. 
        tags => "video"
        jdbc_connection_string => "jdbc:mysql://msql:3308/mydb"
        jdbc_user => "root"
        jdbc_password => "i2TU9Xplv7tvwAhV"
        # Driver
        jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mysql/mysql-connector-java-8.0.21.jar"
        # Drive class name
        jdbc_driver_class => "com.mysql.jdbc.Driver"
        jdbc_paging_enabled => "true"
        jdbc_page_size => "100"
        jdbc_default_timezone => "utc"
        # sql file name
        statement_filepath => "/usr/share/logstash/config/mysql/task.sql"
        # Monitoring interval [minute, hour, day, month, year]
        schedule => "* * * * *"
        # Whether to record the last execution result. If it is true, the value of the tracking column field last executed will be recorded and saved in the file specified by last run metadata path
        record_last_run => true
        use_column_value => true
        tracking_column => "name"
        statement => "SELECT * FROM video;"
        last_run_metadata_path => "./last_record/logstash_video_last_time"
        # Whether to clear the record of last run metadata path? If it is true, each time is equivalent to querying all database records from the beginning
        clean_run => false
        # Convert the field (column) name to lowercase
        lowercase_column_names => true
    }
}

output {
    elasticsearch {
        # The same reason is that the internal access of this docker project needs network bridging
        hosts => ["http://elasticsearch:9200"]
        if "video" in [tags] {
            index => "video"
            document_id => "%{id}"
        }
    }
    stdout{codec => rubydebug }
}